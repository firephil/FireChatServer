package firesoft.firechat.server;

import java.io.*;
import java.net.*;
import java.util.Iterator;
import java.util.Date;
import java.text.DateFormat;

class ClientHandler extends Thread
   {
	   private Socket clientSocket;
	   private DataInputStream inStream;
	   DataOutputStream outStream; //not private so all handlers can access it
	   private Iterator iterator;

	   private String userName;
	   private String password;
	   Date loginDate;
	   String clientIp;
	   int clientPort;
	   int localPort;
	   private DateFormat dateFormat;

       boolean STOP;



       ClientHandler(Socket socket)
       {
	   clientSocket = socket;
	   clientIp = socket.getInetAddress().toString();
	   clientPort = socket.getPort();
	   localPort = socket.getLocalPort();
	   STOP = false;
	   dateFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT,DateFormat.SHORT);
	}

       String getUserName()
       {return this.userName;}

       String getPassword()
       {return this.password;}


       //start running the thread
       public void run()
       {
           //setup IO streams for communication
	   if(setupIO()==false)
             return;
		 try
		 {
			 while (STOP == false)
			 {
				 if (decodeMsg(read()) == true)
					 continue;

			 }
		 }
	     catch(IOException e)
	     {
		 //if an exception occured generated by the read method signal
		 //to stop the thread that the clienthandler is running on
		 disconnectClient();
	     }

       }

       private boolean setupIO()
       {
	   try
	   {
	       inStream = new DataInputStream(new BufferedInputStream(
		   clientSocket.getInputStream()));

	       outStream = new DataOutputStream(new BufferedOutputStream(
		   clientSocket.getOutputStream()));
		System.out.println("Streams created for the client");
	   }
	   catch (IOException e)
	   {
	       return false;
	   }

	   return true;
       }


       private NetPacket read() throws IOException
       {
		   NetPacket packet = new NetPacket();

		   packet.command = inStream.readInt();
		   packet.message = inStream.readUTF();
		   packet.from = inStream.readUTF();
		   packet.recipient = inStream.readUTF();
		   packet.userName = inStream.readUTF();
		   packet.password = inStream.readUTF();

		   return packet;
       }

	private boolean decodeMsg(NetPacket packet)
	{
	    switch (packet.command)
	    {
		case PROTOCOL.PUBLIC:

		    sendPublic(packet);
		    break;

		case PROTOCOL.PRIVATE:

		    sendPrivate(packet);
		    break;

		case PROTOCOL.LOGGON:

		    if (logginUser(packet) == true)
		    {
			updateUserList(PROTOCOL.ADD_USER);
			System.out.println("user "+this.userName+" has logged in");
			return true;
		    }
		    break;

		case PROTOCOL.LOGOFF:
		    updateUserList(PROTOCOL.REMOVE_USER);
		    break;

		default:
		    return false;
	    }
	    return true;//succesfull decoding
	}

      // prevent access to this method by multiple clienthandlers
      //simultaneously which could cause data corruption
       synchronized boolean write(NetPacket packet,ClientHandler destClient)
       {
          try
	  {
	      destClient.outStream.writeInt(packet.command);
	      destClient.outStream.writeUTF(packet.message);
	      destClient.outStream.writeUTF(packet.from);
	      destClient.outStream.writeUTF(packet.recipient);
	      destClient.outStream.writeUTF(packet.userName);
	      destClient.outStream.writeUTF(packet.password);
	      destClient.outStream.flush(); //force write to the underlying stream
               return true;
           }
           catch(IOException e)
           {
               System.out.println(ERROR.WRITE);
               System.out.println(e.getMessage());
               return false;
           }
       }

       private boolean logginUser(NetPacket packet)
       {
	   this.userName = packet.userName;
	   this.password = packet.password;
	   packet.clear(); //clear the packet to reuse it
	   if (Server.userRecords.add(this) == false)
	   {
	       packet.command = PROTOCOL.LOGGIN_FAILED;
	       write(packet, this);
	       return false;
	   }
	   loginDate = new Date();//holds the current date and time
	   Server.gui.print("User "+this.userName+" has logged in at "
						+dateFormat.format(loginDate).toString());
	   //send confirmation to the user that the login was successfull
	   packet.command = PROTOCOL.LOGGIN_SUCCESS;
	   write(packet, this);

           sendUserList();
	   return true;
       }

       private boolean sendPublic(NetPacket packet)
       {
	   //make iterator point to the userRecords iterator
	   iterator = Server.userRecords.getIterator();
	   ClientHandler temp;

	   //retrieve all the ClientHandlers and call their
	   //write method
	   while (iterator.hasNext())
	   {
	       temp = (ClientHandler) iterator.next();
	       temp.write(packet,temp);
	   }

	   return true;
       }

       private boolean sendPrivate(NetPacket packet)
       {
	   //send to the recipient
	   ClientHandler client = Server.userRecords.getHandler(packet.recipient);
	   client.write(packet,client);

           //send the message to its author
           client = Server.userRecords.getHandler(packet.from);
	   client.write(packet,client);
	   return true;
       }

       //informs all the users that a new client has logged in.
       private void sendUserList()
       {
	   ClientHandler tmpHandler;
	   Iterator it = Server.userRecords.getIterator();

	   //get the number of users that are logged in the chat
	   int numUsers = Server.userRecords.size();
	   try
	   {
	       //if there are no other users no need to update
	       if (numUsers == 1)
	       {
		   this.outStream.writeInt(numUsers);
		   this.outStream.flush();
		   return;
	       }
	       String users[] = new String[numUsers];

	       for (int i = 0; i < numUsers; i++)
	       {
		   tmpHandler = (ClientHandler) it.next();
		   users[i] = tmpHandler.getUserName();
	       }

	       for (int i = 0; i < numUsers; i++)
	       {

		   if (i == 0) //send the size of the string array
		       this.outStream.writeInt(numUsers);

		   this.outStream.writeUTF(users[i]);
		   this.outStream.flush();

	       }
	   }
	   catch (IOException e)
	   {
	       //failed to write to one of the clients
	       //disconnect the client
	       //send a notifacation to all users
	       //continue sending to the rest.
	       this.disconnectClient();
	       updateUserList(PROTOCOL.REMOVE_USER);
	   }
       }

       //notify all users to add or remove this user from their list
	   private void updateUserList(int command)
	   {
		   Iterator it = Server.userRecords.getIterator();
		   ClientHandler tmpHandler;

		   while (it.hasNext())
		   {
			   tmpHandler = (ClientHandler) it.next();
			   if (tmpHandler == this) //don't notify the user that was just added
				   continue;
			   NetPacket temp = new NetPacket();
			   temp.command = command; //add or remove
			   temp.message = this.userName;
			   tmpHandler.write(temp, tmpHandler);
		   }
	   }
	   /**
		* Disconnects the client from the chat.
		* TODO: Implement this method more cleanly so i don't have to use
		* the deprececated method Thread.stop().
		*  The flage STOP doesn't work because the Thread is blocked by the
		* read() method.
		*/

	void disconnectClient()
	{
		try
		{
			if (this.clientSocket.isConnected())
			{
				NetPacket packet = new NetPacket();
				if(Server.STOP)
					packet.command = PROTOCOL.SERVER_STOPPED;
				else
					packet.command = PROTOCOL.REMOVE_USER;
				packet.message = this.userName;
				this.write(packet,this);

			}
			Server.userRecords.remove(this);
			Server.gui.print("User "+this.userName+"has left the chat");
			this.inStream.close();
			this.outStream.close();
			this.clientSocket.close();

			if (this.isAlive()) //test this?
				this.stop();
		}
		catch (IOException e)
		{}
	}
}




